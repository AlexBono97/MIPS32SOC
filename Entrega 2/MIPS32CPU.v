/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_ROM_256X32 (
    input [7:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:8];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 8'h8)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h43402a;
        my_rom[1] = 32'h11070005;
        my_rom[2] = 32'h12820;
        my_rom[3] = 32'h260020;
        my_rom[4] = 32'ha60820;
        my_rom[5] = 32'h671820;
        my_rom[6] = 32'h8000000;
        my_rom[7] = 32'h260820;
        my_rom[8] = 32'h8000007;
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module JumpTarget(
	input [25:0] in,
	input [31:0] pc4,
	output [31:0] out 
);

assign out = {pc4[31:28], in, 2'b0};

endmodule
module BranchTarget(
	input [15:0] imm,
	input [31:0] pc4,
	output [31:0] out
);

wire [31:0] signExt;

assign signExt = {{16{imm[15]}}, imm};

assign out = {signExt[29:0], 2'b0} + pc4;

endmodule
module alu(
	input[31:0] a,
	input[31:0] b,
	input[2:0] op,
	output reg[31:0] r,
	output isZ
);

assign isZ = r == 32'd0;

always@(*)
begin
	case(op)
		3'd0: r = a + b;
		3'd1: r = a - b;
		3'd2: r = a & b;
		3'd3: r = a | b;
		3'd4: r = {31'd0, $signed(a) < $signed(b)};
		default: r = 32'dX;
	endcase
end

endmodule
module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule



module datamemory(
    input clk,
    input [7:0]addr,
    input [31:0]wData,
    input mwrite,
    input mread,
    output reg[31:0]rdata
); 

reg [63:0] memory[31:0];

always @(posedge clk)
begin
    if(mwrite)
        memory[addr]<=wData;
end

always @(*)
begin
    if(mread)
    	rdata<=memory[addr];
end

endmodule
module regfile(
input clk,
input [4:0]Ra,
input [4:0]Rb,
input [4:0]Rw,
input we,
input [31:0]din,
output reg [31:0]Da,
output reg [31:0]Db
);

reg [31:0] memory[31:0];

//seteando registros
initial begin
	    memory[0]=32'd0;
            memory[1]=32'd1;
	    memory[2]=32'd5;
	    memory[3]=32'd1;
	    memory[6]=32'd0;
	    memory[7]=32'd1;
end

always @(posedge clk)
begin
    if(we)
        memory[Rw]<=din;
    

end

always @(*)
begin
  
    
    Da<=memory[Ra];
    Db<=memory[Rb];
end
endmodule
module controlunit(
    input [5:0] opcode,
    output reg RegDst,
    output reg branch,
    output reg memread,
    output reg memwrite,
    output reg memtoReg,
    output reg [1:0]ALUop,
    output reg Alusrc,
    output reg regwrite,
    output reg jump,
    output reg bne
);

always @(*)
begin
    case (opcode)
      6'd0://R-Format((add,sub,and,or,slt)
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b1,1'b0,1'b0,1'b1,1'b0,1'b0,1'b0,2'b10,1'b0,1'b0};
      6'd2://Jump
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,2'b00,1'b1,1'b0};
      6'd4://beq
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b1,2'b01,1'b0,1'b0};
      6'd5://bne
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,2'b01,1'b0,1'b1};
      6'd35://load
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b0,1'b1,1'b1,1'b1,1'b1,1'b0,1'b0,2'b00,1'b0,1'b0};
      6'd43://store
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'b0,1'b1,1'b0,1'b0,1'b0,1'b1,1'b0,2'b00,1'b0,1'b0};

      default: 
            {RegDst,Alusrc,memtoReg,regwrite,memread,memwrite,branch,ALUop,jump,bne} = {1'bx,1'bx,1'bx,1'bx,1'bx,1'bx,1'bx,2'bxx,1'bx,1'bx};
    endcase
end

endmodule
module alucontrol(
    input [1:0] aluop,
    input [5:0] func,
    output reg[2:0] op
);


always @(*)
begin
    case (aluop)
      2'b00:
            op = 3'd0;//suma para lw y sw
      2'b01:
            op = 3'd1;//resta para el beq
      2'b10://R-Format
            case (func)
                6'b100000:
                        op = 3'd0;//suma 
                6'b100010:
                        op = 3'd1;//resta
                6'b100100:
                        op = 3'd2;//AND
                6'b100101:
                        op = 3'd3;//OR
                6'b101010:
                        op = 3'd4;//set less than
            default: 
                        op = 3'dx;
            endcase
      default:
            op = 3'dx; 
    endcase
end

endmodule

module MIPS32CPU (
  input clk
);
  wire [7:0] s0;
  wire [31:0] Ins;
  wire [31:0] s1;
  wire [31:0] s2;
  wire [31:0] s3;
  wire jump;
  wire [31:0] s4;
  wire [31:0] s5;
  wire s6;
  wire [31:0] s7;
  wire [25:0] s8;
  wire [15:0] i_15_0;
  wire [31:0] s9;
  wire [31:0] s10;
  wire [2:0] opcontrol;
  wire [31:0] s11;
  wire isZ;
  wire ALUsrc;
  wire [31:0] s12;
  wire [31:0] s13;
  wire [5:0] func;
  wire [4:0] sa;
  wire [4:0] rd;
  wire [4:0] rt;
  wire [4:0] rs;
  wire [5:0] op;
  wire RegDst;
  wire [4:0] s14;
  wire memtoReg;
  wire [31:0] s15;
  wire [31:0] rwd;
  wire [7:0] s16;
  wire memread;
  wire memwrite;
  wire regwrite;
  wire branch;
  wire [1:0] ALUop;
  wire branche;
  // Ins_mem
  DIG_ROM_256X32 DIG_ROM_256X32_i0 (
    .A( s0 ),
    .sel( 1'b1 ),
    .D( Ins )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(32)
  )
  DIG_Register_BUS_i1 (
    .D( s1 ),
    .C( clk ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  // pc+4
  DIG_Add #(
    .Bits(32)
  )
  DIG_Add_i2 (
    .a( s2 ),
    .b( 32'b100 ),
    .c_i( 1'b0 ),
    .s( s3 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i3 (
    .sel( jump ),
    .in_0( s4 ),
    .in_1( s5 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i4 (
    .sel( s6 ),
    .in_0( s3 ),
    .in_1( s7 ),
    .out( s4 )
  );
  // JumpTarget
  JumpTarget JumpTarget_i5 (
    .in( s8 ),
    .pc4( s3 ),
    .out( s5 )
  );
  // BranchTarget
  BranchTarget BranchTarget_i6 (
    .imm( i_15_0 ),
    .pc4( s3 ),
    .out( s7 )
  );
  // alu
  alu alu_i7 (
    .a( s9 ),
    .b( s10 ),
    .op( opcontrol ),
    .r( s11 ),
    .isZ( isZ )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i8 (
    .sel( ALUsrc ),
    .in_0( s12 ),
    .in_1( s13 ),
    .out( s10 )
  );
  // SignEx
  DIG_BitExtender #(
    .inputBits(16),
    .outputBits(32)
  )
  DIG_BitExtender_i9 (
    .in( i_15_0 ),
    .out( s13 )
  );
  Mux_2x1_NBits #(
    .Bits(5)
  )
  Mux_2x1_NBits_i10 (
    .sel( RegDst ),
    .in_0( rt ),
    .in_1( rd ),
    .out( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(32)
  )
  Mux_2x1_NBits_i11 (
    .sel( memtoReg ),
    .in_0( s11 ),
    .in_1( s15 ),
    .out( rwd )
  );
  // datamemory
  datamemory datamemory_i12 (
    .clk( clk ),
    .addr( s16 ),
    .wData( s12 ),
    .mwrite( memread ),
    .mread( memwrite ),
    .rdata( s15 )
  );
  // regfile
  regfile regfile_i13 (
    .clk( clk ),
    .Ra( rs ),
    .Rb( rt ),
    .Rw( s14 ),
    .we( regwrite ),
    .din( rwd ),
    .Da( s9 ),
    .Db( s12 )
  );
  // controlunit
  controlunit controlunit_i14 (
    .opcode( op ),
    .RegDst( RegDst ),
    .branch( branch ),
    .memread( memread ),
    .memwrite( memwrite ),
    .memtoReg( memtoReg ),
    .ALUop( ALUop ),
    .Alusrc( ALUsrc ),
    .regwrite( regwrite ),
    .jump( jump ),
    .bne( branche )
  );
  // alucontrol
  alucontrol alucontrol_i15 (
    .aluop( ALUop ),
    .func( func ),
    .op( opcontrol )
  );
  assign s6 = ((isZ & branch) | (branche & ~ isZ));
  assign s0 = s2[9:2];
  assign s8 = Ins[25:0];
  assign i_15_0 = Ins[15:0];
  assign func = Ins[5:0];
  assign sa = Ins[10:6];
  assign rd = Ins[15:11];
  assign rt = Ins[20:16];
  assign rs = Ins[25:21];
  assign op = Ins[31:26];
  assign s16 = s11[9:2];
endmodule
