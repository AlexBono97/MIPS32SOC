/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule


module pcdecoder(
    input [31:0] vpc,
    output reg[9:0] ppc,
    output reg invpc
);

parameter [31:0] startp=32'h400000 ;
parameter [31:0] endp=32'h401000 ;

always @(*)
begin
    if(vpc>=startp 
    & vpc<endp)begin
            ppc = vpc - startp;
	    invpc = 1'b0;
    end else begin
        invpc = 1'b1;
        ppc = 7'dx;
    end
end
endmodule
module shift(
	input [9:0] in,
	output [9:0] out
);

assign out = in >> 2;

endmodule
module DIG_ROM_1024X32 (
    input [9:0] A,
    input sel,
    output reg [31:0] D
);
    reg [31:0] my_rom [0:6];

    always @ (*) begin
        if (~sel)
            D = 32'hz;
        else if (A > 10'h6)
            D = 32'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 32'h3c101001;
        my_rom[1] = 32'h26100000;
        my_rom[2] = 32'h3408aabb;
        my_rom[3] = 32'h3409ccdd;
        my_rom[4] = 32'ha6080000;
        my_rom[5] = 32'ha6090002;
        my_rom[6] = 32'h8100006;
    end
endmodule

